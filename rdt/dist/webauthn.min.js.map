{
  "version": 3,
  "sources": ["../src/client.ts", "../src/utils.ts", "../src/server.ts", "../src/parsers.ts", "../src/authenticatorMetadata.ts", "../src/authenticators.ts"],
  "sourcesContent": ["import * as utils from './utils'\r\nimport { AuthenticateOptions, AuthenticationEncoded, AuthType, NamedAlgo, NumAlgo, RegisterOptions, RegistrationEncoded } from './types'\r\n\r\n/**\r\n * Returns whether passwordless authentication is available on this browser/platform or not.\r\n */\r\n export function isAvailable() :boolean {\r\n    return !!window.PublicKeyCredential\r\n}\r\n\r\n/**\r\n * Returns whether the device itself can be used as authenticator.\r\n */\r\nexport async function isLocalAuthenticator() :Promise<boolean> {\r\n    return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\r\n}\r\n\r\n\r\n\r\n\r\nasync function getAuthAttachment(authType :AuthType) :Promise<AuthenticatorAttachment|undefined> {\r\n    if(authType === \"local\")\r\n        return \"platform\";\r\n    if(authType === \"roaming\" || authType === \"extern\")\r\n        return \"cross-platform\";\r\n    if(authType === \"both\")\r\n        return undefined // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\r\n\r\n    // the default case: \"auto\", depending on device capabilities\r\n    try {\r\n        if(await isLocalAuthenticator())\r\n            return \"platform\"\r\n        else\r\n            return \"cross-platform\"\r\n    } catch(e) {\r\n        // might happen due to some security policies\r\n        // see https://w3c.github.io/webauthn/#sctn-isUserVerifyingPlatformAuthenticatorAvailable\r\n        return undefined // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction getAlgoName(num :NumAlgo) :NamedAlgo {\r\n    switch(num) {\r\n        case -7: return \"ES256\"\r\n        // case -8 ignored to to its rarity\r\n        case -257: return \"RS256\"\r\n        default: throw new Error(`Unknown algorithm code: ${num}`)\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Creates a cryptographic key pair, in order to register the public key for later passwordless authentication.\r\n *\r\n * @param {string} username\r\n * @param {string} challenge A server-side randomly generated string.\r\n * @param {Object} [options] Optional parameters.\r\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\r\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\r\n * @param {'auto'|'local'|'roaming'|'both'}       [options.authenticatorType='auto'] Which device to use as authenticator.\r\n *          'auto': if the local device can be used as authenticator it will be preferred. Otherwise it will prompt for a roaming device.\r\n *          'local': use the local device (using TouchID, FaceID, Windows Hello or PIN)\r\n *          'roaming': use a roaming device (security key or connected phone)\r\n *          'both': prompt the user to choose between local or roaming device. The UI and user interaction in this case is platform specific.\r\n * @param {boolean} [attestation=false] If enabled, the device attestation and clientData will be provided as Base64url encoded binary data.\r\n *                                Note that this is not available on some platforms.\r\n */\r\nexport async function register(username :string, challenge :string, options? :RegisterOptions) :Promise<RegistrationEncoded> {\r\n    options = options ?? {}\r\n\r\n    if(!utils.isBase64url(challenge))\r\n        throw new Error('Provided challenge is not properly encoded in Base64url')\r\n\r\n    const creationOptions :PublicKeyCredentialCreationOptions = {\r\n        challenge: utils.parseBase64url(challenge),\r\n        rp: {\r\n            id: window.location.hostname,\r\n            name: window.location.hostname\r\n        },\r\n        user: {\r\n            id: await utils.sha256(new TextEncoder().encode(username)), // ID should not be directly \"identifiable\" for privacy concerns\r\n            name: username,\r\n            displayName: username,\r\n        },\r\n        pubKeyCredParams: [\r\n            {alg: -7, type: \"public-key\"},   // ES256 (Webauthn's default algorithm)\r\n            {alg: -257, type: \"public-key\"}, // RS256 (for Windows Hello and others)\r\n        ],\r\n        timeout: options.timeout ?? 60000,\r\n        authenticatorSelection: {\r\n            userVerification: options.userVerification ?? \"required\", // Webauthn default is \"preferred\"\r\n            authenticatorAttachment: await getAuthAttachment(options.authenticatorType ?? \"auto\"),\r\n        },\r\n        attestation: \"direct\" // options.attestation ? \"direct\" : \"none\"\r\n    }\r\n\r\n    if(options.debug)\r\n        console.debug(creationOptions)\r\n\r\n    const credential = await navigator.credentials.create({publicKey: creationOptions}) as any //PublicKeyCredential\r\n    \r\n    if(options.debug)\r\n        console.debug(credential)\r\n   \r\n    const response = credential.response as any // AuthenticatorAttestationResponse\r\n    \r\n    let registration :RegistrationEncoded = {\r\n        username: username,\r\n        credential: {\r\n            id: credential.id,\r\n            publicKey: utils.toBase64url(response.getPublicKey()),\r\n            algorithm: getAlgoName(credential.response.getPublicKeyAlgorithm())\r\n        },\r\n        authenticatorData: utils.toBase64url(response.getAuthenticatorData()),\r\n        clientData: utils.toBase64url(response.clientDataJSON),\r\n    }\r\n\r\n    if(options.attestation) {\r\n        registration.attestationData = utils.toBase64url(response.attestationObject)\r\n    }\r\n\r\n    return registration\r\n}\r\n\r\n\r\nasync function getTransports(authType :AuthType) :Promise<AuthenticatorTransport[]> {\r\n    const local  :AuthenticatorTransport[] = ['internal']\r\n\r\n    // 'hybrid' was added mid-2022 in the specs and currently not yet available in the official dom types\r\n    // @ts-ignore\r\n    const roaming :AuthenticatorTransport[] = ['hybrid', 'usb', 'ble', 'nfc']\r\n    \r\n    if(authType === \"local\")\r\n        return local\r\n    if(authType == \"roaming\" || authType === \"extern\")\r\n        return roaming\r\n    if(authType === \"both\")\r\n        return [...local, ...roaming]\r\n\r\n    // the default case: \"auto\", depending on device capabilities\r\n    try {\r\n        if(await isLocalAuthenticator())\r\n            return local\r\n        else\r\n            return roaming\r\n    } catch(e) {\r\n        return [...local, ...roaming]\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Signs a challenge using one of the provided credentials IDs in order to authenticate the user.\r\n *\r\n * @param {string[]} credentialIds The list of credential IDs that can be used for signing.\r\n * @param {string} challenge A server-side randomly generated string, the base64 encoded version will be signed.\r\n * @param {Object} [options] Optional parameters.\r\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\r\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\r\n */\r\nexport async function authenticate(credentialIds :string[], challenge :string, options? :AuthenticateOptions) :Promise<AuthenticationEncoded> {\r\n    options = options ?? {}\r\n\r\n    if(!utils.isBase64url(challenge))\r\n        throw new Error('Provided challenge is not properly encoded in Base64url')\r\n\r\n    const transports = await getTransports(options.authenticatorType ?? \"auto\");\r\n\r\n    let authOptions :PublicKeyCredentialRequestOptions = {\r\n        challenge: utils.parseBase64url(challenge),\r\n        rpId: window.location.hostname,\r\n        allowCredentials: credentialIds.map(id => { return {\r\n            id: utils.parseBase64url(id),\r\n            type: 'public-key',\r\n            transports: transports,\r\n        }}),\r\n        userVerification: options.userVerification ?? \"required\",\r\n        timeout: options.timeout ?? 60000,\r\n    }\r\n\r\n    if(options.debug)\r\n        console.debug(authOptions)\r\n\r\n    let auth = await navigator.credentials.get({publicKey: authOptions}) as PublicKeyCredential\r\n    \r\n    if(options.debug)\r\n        console.debug(auth)\r\n\r\n    const response = auth.response as AuthenticatorAssertionResponse\r\n    \r\n    const authentication :AuthenticationEncoded = {\r\n        credentialId: auth.id,\r\n        //userHash: utils.toBase64url(response.userHandle), // unreliable, optional for authenticators\r\n        authenticatorData: utils.toBase64url(response.authenticatorData),\r\n        clientData: utils.toBase64url(response.clientDataJSON),\r\n        signature: utils.toBase64url(response.signature),\r\n    }\r\n\r\n    return authentication\r\n}\r\n\r\n", "/********************************\r\n     Encoding/Decoding Utils\r\n********************************/\r\n\r\n/*\r\nlet webCrypto :any = null\r\n\r\nexport async function getCrypto() {\r\n    if(!webCrypto) {\r\n        console.log(window?.crypto)\r\n        webCrypto = window?.crypto ?? (await import(\"crypto\")).webcrypto\r\n        console.log(webCrypto)\r\n    }\r\n    return webCrypto\r\n}\r\n*/\r\n\r\n\r\nexport function randomChallenge() {\r\n    return crypto.randomUUID()\r\n}\r\n\r\n\r\nexport function toBuffer(txt :string) :ArrayBuffer {\r\n    return Uint8Array.from(txt, c => c.charCodeAt(0)).buffer\r\n}\r\n\r\nexport function parseBuffer(buffer :ArrayBuffer) :string {\r\n    return String.fromCharCode(...new Uint8Array(buffer))\r\n}\r\n\r\n\r\nexport function isBase64url(txt :string) :boolean {\r\n    return txt.match(/^[a-zA-Z0-9\\-_]+=*$/) !== null\r\n}\r\n\r\nexport function toBase64url(buffer :ArrayBuffer) :string {\r\n    const txt = btoa(parseBuffer(buffer)) // base64\r\n    return txt.replaceAll('+', '-').replaceAll('/', '_')\r\n}\r\n\r\nexport function parseBase64url(txt :string) :ArrayBuffer {\r\n    txt = txt.replaceAll('-', '+').replaceAll('_', '/') // base64url -> base64\r\n    return toBuffer(atob(txt))\r\n}\r\n\r\n\r\nexport async function sha256(buffer :ArrayBuffer) :Promise<ArrayBuffer> {\r\n    return await crypto.subtle.digest('SHA-256', buffer)\r\n}\r\n\r\nexport function bufferToHex (buffer :ArrayBuffer) :string {\r\n    return [...new Uint8Array (buffer)]\r\n        .map (b => b.toString (16).padStart (2, \"0\"))\r\n        .join (\"\");\r\n}\r\n\r\n\r\nexport function concatenateBuffers(buffer1 :ArrayBuffer, buffer2  :ArrayBuffer) {\r\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\r\n    tmp.set(new Uint8Array(buffer1), 0);\r\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\r\n    return tmp;\r\n  };", "import { parseAuthentication, parseRegistration } from \"./parsers\";\r\nimport { AuthenticationEncoded, AuthenticationParsed, CredentialKey, NamedAlgo, RegistrationEncoded, RegistrationParsed } from \"./types\";\r\nimport * as utils from './utils'\r\n\r\n\r\nasync function isValid(validator :any, value :any) :Promise<boolean> {\r\n   if(typeof validator === 'function') {\r\n        const res = validator(value)\r\n        if(res instanceof Promise)\r\n            return await res\r\n        else\r\n            return res\r\n    }\r\n    // the validator can be a single value too\r\n    return validator === value\r\n}\r\n\r\nasync function isNotValid(validator :any, value :any) :Promise<boolean> {\r\n    return !(await isValid(validator, value))\r\n}\r\n\r\ninterface RegistrationChecks {\r\n    challenge: string | Function,\r\n    origin: string | Function\r\n}\r\n\r\n\r\nexport async function verifyRegistration(registrationRaw: RegistrationEncoded, expected: RegistrationChecks): Promise<RegistrationParsed> {\r\n    const registration = parseRegistration(registrationRaw)\r\n    registration.client.challenge\r\n\r\n    if (registration.client.type !== \"webauthn.create\")\r\n        throw new Error(`Unexpected ClientData type: ${registration.client.type}`)\r\n\r\n    if (await isNotValid(expected.origin, registration.client.origin))\r\n        throw new Error(`Unexpected ClientData origin: ${registration.client.origin}`)\r\n\r\n    if (await isNotValid(expected.challenge, registration.client.challenge))\r\n        throw new Error(`Unexpected ClientData challenge: ${registration.client.challenge}`)\r\n\r\n    return registration\r\n}\r\n\r\n\r\ninterface AuthenticationChecks {\r\n    challenge: string | Function,\r\n    origin: string | Function,\r\n    userVerified: boolean,\r\n    counter: number\r\n}\r\n\r\n\r\nexport async function verifyAuthentication(authenticationRaw: AuthenticationEncoded, credential: CredentialKey, expected: AuthenticationChecks): Promise<AuthenticationParsed> {\r\n    if (authenticationRaw.credentialId !== credential.id)\r\n        throw new Error(`Credential ID mismatch: ${authenticationRaw.credentialId} vs ${credential.id}`)\r\n\r\n    const isValidSignature: boolean = await verifySignature({\r\n        algorithm: credential.algorithm,\r\n        publicKey: credential.publicKey,\r\n        authenticatorData: authenticationRaw.authenticatorData,\r\n        clientData: authenticationRaw.clientData,\r\n        signature: authenticationRaw.signature\r\n    })\r\n\r\n    if(!isValidSignature)\r\n        throw new Error(`Invalid signature: ${authenticationRaw.signature}`)\r\n\r\n    const authentication = parseAuthentication(authenticationRaw)\r\n\r\n    if (authentication.client.type !== \"webauthn.get\")\r\n        throw new Error(`Unexpected clientData type: ${authentication.client.type}`)\r\n\r\n    if (await isNotValid(expected.origin, authentication.client.origin))\r\n        throw new Error(`Unexpected ClientData origin: ${authentication.client.origin}`)\r\n\r\n    if (await isNotValid(expected.challenge, authentication.client.challenge))\r\n        throw new Error(`Unexpected ClientData challenge: ${authentication.client.challenge}`)\r\n\r\n    // this only works because we consider `rp.origin` and `rp.id` to be the same during authentication/registration\r\n    const rpId = new URL(authentication.client.origin).hostname\r\n    const expectedRpIdHash = utils.toBase64url(await utils.sha256(utils.toBuffer(rpId)))\r\n    if (authentication.authenticator.rpIdHash !== expectedRpIdHash)\r\n        throw new Error(`Unexpected RpIdHash: ${authentication.authenticator.rpIdHash} vs ${expectedRpIdHash}`)\r\n\r\n    if (!authentication.authenticator.flags.userPresent)\r\n        throw new Error(`Unexpected authenticator flags: missing userPresent`)\r\n\r\n    if (!authentication.authenticator.flags.userVerified && expected.userVerified)\r\n        throw new Error(`Unexpected authenticator flags: missing userVerified`)\r\n\r\n    if (authentication.authenticator.counter <= expected.counter)\r\n        throw new Error(`Unexpected authenticator counter: ${authentication.authenticator.counter} (should be > ${expected.counter})`)\r\n\r\n    return authentication\r\n}\r\n\r\n\r\n// https://w3c.github.io/webauthn/#sctn-public-key-easy\r\n// https://www.iana.org/assignments/cose/cose.xhtml#algorithms\r\n/*\r\nUser agents MUST be able to return a non-null value for getPublicKey() when the credential public key has a COSEAlgorithmIdentifier value of:\r\n\r\n-7 (ES256), where kty is 2 (with uncompressed points) and crv is 1 (P-256).\r\n\r\n-257 (RS256).\r\n\r\n-8 (EdDSA), where crv is 6 (Ed25519).\r\n*/\r\nfunction getAlgoParams(algorithm: NamedAlgo): any {\r\n    switch (algorithm) {\r\n        case 'RS256':\r\n            return {\r\n                name: 'RSASSA-PKCS1-v1_5',\r\n                hash: 'SHA-256'\r\n            };\r\n        case 'ES256':\r\n            return {\r\n                name: 'ECDSA',\r\n                namedCurve: 'P-256',\r\n                hash: 'SHA-256',\r\n            };\r\n        // case 'EdDSA': Not supported by browsers\r\n        default:\r\n            throw new Error(`Unknown or unsupported crypto algorithm: ${algorithm}. Only 'RS256' and 'ES256' are supported.`)\r\n    }\r\n}\r\n\r\ntype AlgoParams = AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm\r\n\r\nasync function parseCryptoKey(algoParams: AlgoParams, publicKey: string): Promise<CryptoKey> {\r\n    const buffer = utils.parseBase64url(publicKey)\r\n    return crypto.subtle.importKey('spki', buffer, algoParams, false, ['verify'])\r\n}\r\n\r\n\r\n\r\ntype VerifyParams = {\r\n    algorithm: NamedAlgo,\r\n    publicKey: string, // Base64url encoded\r\n    authenticatorData: string, // Base64url encoded\r\n    clientData: string, // Base64url encoded\r\n    signature: string, // Base64url encoded\r\n}\r\n\r\n\r\n// https://w3c.github.io/webauthn/#sctn-verifying-assertion\r\n// https://w3c.github.io/webauthn/#sctn-signature-attestation-types\r\n/* Emphasis mine:\r\n\r\n6.5.6. Signature Formats for Packed Attestation, FIDO U2F Attestation, and **Assertion Signatures**\r\n\r\n[...] For COSEAlgorithmIdentifier -7 (ES256) [...] the sig value MUST be encoded as an ASN.1 [...]\r\n[...] For COSEAlgorithmIdentifier -257 (RS256) [...] The signature is not ASN.1 wrapped.\r\n[...] For COSEAlgorithmIdentifier -37 (PS256) [...] The signature is not ASN.1 wrapped.\r\n*/\r\n// see also https://gist.github.com/philholden/50120652bfe0498958fd5926694ba354\r\nexport async function verifySignature({ algorithm, publicKey, authenticatorData, clientData, signature }: VerifyParams): Promise<boolean> {\r\n    const algoParams = getAlgoParams(algorithm)\r\n    let cryptoKey = await parseCryptoKey(algoParams, publicKey)\r\n    console.debug(cryptoKey)\r\n\r\n    let clientHash = await utils.sha256(utils.parseBase64url(clientData));\r\n\r\n    // during \"login\", the authenticatorData is exactly 37 bytes\r\n    let comboBuffer = utils.concatenateBuffers(utils.parseBase64url(authenticatorData), clientHash)\r\n\r\n    console.debug('Crypto Algo: ' + JSON.stringify(algoParams))\r\n    console.debug('Public key: ' + publicKey)\r\n    console.debug('Data: ' + utils.toBase64url(comboBuffer))\r\n    console.debug('Signature: ' + signature)\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify\r\n    let signatureBuffer = utils.parseBase64url(signature)\r\n    if(algorithm == 'ES256')\r\n        signatureBuffer = convertASN1toRaw(signatureBuffer)\r\n\r\n    const isValid = await crypto.subtle.verify(algoParams, cryptoKey, signatureBuffer, comboBuffer)\r\n\r\n    return isValid\r\n}\r\n\r\nfunction convertASN1toRaw(signatureBuffer :ArrayBuffer) {\r\n    // Convert signature from ASN.1 sequence to \"raw\" format\r\n    const usignature = new Uint8Array(signatureBuffer);\r\n    const rStart = usignature[4] === 0 ? 5 : 4;\r\n    const rEnd = rStart + 32;\r\n    const sStart = usignature[rEnd + 2] === 0 ? rEnd + 3 : rEnd + 2;\r\n    const r = usignature.slice(rStart, rEnd);\r\n    const s = usignature.slice(sStart);\r\n    return new Uint8Array([...r, ...s]);\r\n}", "import * as authenticators from './authenticators'\r\nimport * as utils from './utils'\r\nimport { AuthenticatorInfo, ClientInfo, RegistrationEncoded, RegistrationParsed, AuthenticationEncoded, AuthenticationParsed } from './types'\r\n\r\nconst utf8Decoder = new TextDecoder('utf-8')\r\n\r\nexport function parseClient(data :string|ArrayBuffer) :ClientInfo {\r\n    if(typeof data == 'string')\r\n        data = utils.parseBase64url(data)\r\n    return JSON.parse(utf8Decoder.decode(data))\r\n}\r\n\r\n\r\nexport function parseAuthenticator(data :string|ArrayBuffer) :AuthenticatorInfo {\r\n    if(typeof data == 'string')\r\n        data = utils.parseBase64url(data)\r\n    return authenticators.parseAuthBuffer(data)\r\n}\r\n\r\n\r\nexport function parseAttestation(data :string|ArrayBuffer) :unknown {\r\n    if(typeof data == 'string')\r\n        data = utils.parseBase64url(data)\r\n    return 'Really complex to parse. Good luck with that one!'\r\n}\r\n\r\n\r\n\r\nexport function parseRegistration(registration :RegistrationEncoded) :RegistrationParsed {\r\n    return {\r\n        username: registration.username,\r\n        credential: registration.credential,\r\n\r\n        client:        parseClient(registration.clientData),\r\n        authenticator: parseAuthenticator(registration.authenticatorData),\r\n        attestation:   registration.attestationData ? parseAttestation(registration.attestationData) : null\r\n    }\r\n}\r\n\r\nexport function parseAuthentication(authentication :AuthenticationEncoded) :AuthenticationParsed {\r\n    return {\r\n        credentialId:  authentication.credentialId,\r\n        client:        parseClient(authentication.clientData),\r\n        authenticator: parseAuthenticator(authentication.authenticatorData),\r\n        signature: authentication.signature\r\n    }\r\n}", "export default {\r\n  \"9c835346-796b-4c27-8898-d6032f515cc5\": {\r\n    \"name\": \"Cryptnox FIDO2\"\r\n  },\r\n  \"c5ef55ff-ad9a-4b9f-b580-adebafe026d0\": {\r\n    \"name\": \"YubiKey 5Ci\"\r\n  },\r\n  \"39a5647e-1853-446c-a1f6-a79bae9f5bc7\": {\r\n    \"name\": \"Vancosys Android Authenticator\"\r\n  },\r\n  \"3789da91-f943-46bc-95c3-50ea2012f03a\": {\r\n    \"name\": \"NEOWAVE Winkeo FIDO2\"\r\n  },\r\n  \"fa2b99dc-9e39-4257-8f92-4a30d23c4118\": {\r\n    \"name\": \"YubiKey 5 Series with NFC\"\r\n  },\r\n  \"4e768f2c-5fab-48b3-b300-220eb487752b\": {\r\n    \"name\": \"Hideez Key 4 FIDO2 SDK\"\r\n  },\r\n  \"931327dd-c89b-406c-a81e-ed7058ef36c6\": {\r\n    \"name\": \"Swissbit iShield FIDO2\"\r\n  },\r\n  \"e1a96183-5016-4f24-b55b-e3ae23614cc6\": {\r\n    \"name\": \"ATKey.Pro CTAP2.0\"\r\n  },\r\n  \"08987058-cadc-4b81-b6e1-30de50dcbe96\": {\r\n    \"name\": \"Windows Hello Hardware Authenticator\"\r\n  },\r\n  \"d91c5288-0ef0-49b7-b8ae-21ca0aa6b3f3\": {\r\n    \"name\": \"KEY-ID FIDO2 Authenticator\"\r\n  },\r\n  \"ee041bce-25e5-4cdb-8f86-897fd6418464\": {\r\n    \"name\": \"Feitian ePass FIDO2-NFC Authenticator\"\r\n  },\r\n  \"73bb0cd4-e502-49b8-9c6f-b59445bf720b\": {\r\n    \"name\": \"YubiKey 5 FIPS Series\"\r\n  },\r\n  \"149a2021-8ef6-4133-96b8-81f8d5b7f1f5\": {\r\n    \"name\": \"Security Key by Yubico with NFC\"\r\n  },\r\n  \"3b1adb99-0dfe-46fd-90b8-7f7614a4de2a\": {\r\n    \"name\": \"GoTrust Idem Key FIDO2 Authenticator\"\r\n  },\r\n  \"f8a011f3-8c0a-4d15-8006-17111f9edc7d\": {\r\n    \"name\": \"Security Key by Yubico\"\r\n  },\r\n  \"2c0df832-92de-4be1-8412-88a8f074df4a\": {\r\n    \"name\": \"Feitian FIDO Smart Card\"\r\n  },\r\n  \"c5703116-972b-4851-a3e7-ae1259843399\": {\r\n    \"name\": \"NEOWAVE Badgeo FIDO2\"\r\n  },\r\n  \"820d89ed-d65a-409e-85cb-f73f0578f82a\": {\r\n    \"name\": \"Vancosys iOS Authenticator\"\r\n  },\r\n  \"b6ede29c-3772-412c-8a78-539c1f4c62d2\": {\r\n    \"name\": \"Feitian BioPass FIDO2 Plus Authenticator\"\r\n  },\r\n  \"85203421-48f9-4355-9bc8-8a53846e5083\": {\r\n    \"name\": \"YubiKey 5Ci FIPS\"\r\n  },\r\n  \"d821a7d4-e97c-4cb6-bd82-4237731fd4be\": {\r\n    \"name\": \"Hyper FIDO Bio Security Key\"\r\n  },\r\n  \"516d3969-5a57-5651-5958-4e7a49434167\": {\r\n    \"name\": \"SmartDisplayer BobeePass (NFC-BLE FIDO2 Authenticator)\"\r\n  },\r\n  \"b93fd961-f2e6-462f-b122-82002247de78\": {\r\n    \"name\": \"Android Authenticator with SafetyNet Attestation\"\r\n  },\r\n  \"2fc0579f-8113-47ea-b116-bb5a8db9202a\": {\r\n    \"name\": \"YubiKey 5 Series with NFC\"\r\n  },\r\n  \"9ddd1817-af5a-4672-a2b9-3e3dd95000a9\": {\r\n    \"name\": \"Windows Hello VBS Hardware Authenticator\"\r\n  },\r\n  \"d8522d9f-575b-4866-88a9-ba99fa02f35b\": {\r\n    \"name\": \"YubiKey Bio Series\"\r\n  },\r\n  \"692db549-7ae5-44d5-a1e5-dd20a493b723\": {\r\n    \"name\": \"HID Crescendo Key\"\r\n  },\r\n  \"3e22415d-7fdf-4ea4-8a0c-dd60c4249b9d\": {\r\n    \"name\": \"Feitian iePass FIDO Authenticator\"\r\n  },\r\n  \"aeb6569c-f8fb-4950-ac60-24ca2bbe2e52\": {\r\n    \"name\": \"HID Crescendo C2300\"\r\n  },\r\n  \"9f0d8150-baa5-4c00-9299-ad62c8bb4e87\": {\r\n    \"name\": \"GoTrust Idem Card FIDO2 Authenticator\"\r\n  },\r\n  \"12ded745-4bed-47d4-abaa-e713f51d6393\": {\r\n    \"name\": \"Feitian AllinOne FIDO2 Authenticator\"\r\n  },\r\n  \"88bbd2f0-342a-42e7-9729-dd158be5407a\": {\r\n    \"name\": \"Precision InnaIT Key FIDO 2 Level 2 certified\"\r\n  },\r\n  \"34f5766d-1536-4a24-9033-0e294e510fb0\": {\r\n    \"name\": \"YubiKey 5 Series CTAP2.1 Preview 1 \"\r\n  },\r\n  \"83c47309-aabb-4108-8470-8be838b573cb\": {\r\n    \"name\": \"YubiKey Bio Series (Enterprise Profile)\"\r\n  },\r\n  \"be727034-574a-f799-5c76-0929e0430973\": {\r\n    \"name\": \"Crayonic KeyVault K1 (USB-NFC-BLE FIDO2 Authenticator)\"\r\n  },\r\n  \"b92c3f9a-c014-4056-887f-140a2501163b\": {\r\n    \"name\": \"Security Key by Yubico\"\r\n  },\r\n  \"54d9fee8-e621-4291-8b18-7157b99c5bec\": {\r\n    \"name\": \"HID Crescendo Enabled\"\r\n  },\r\n  \"6028b017-b1d4-4c02-b4b3-afcdafc96bb2\": {\r\n    \"name\": \"Windows Hello Software Authenticator\"\r\n  },\r\n  \"6d44ba9b-f6ec-2e49-b930-0c8fe920cb73\": {\r\n    \"name\": \"Security Key by Yubico with NFC\"\r\n  },\r\n  \"e416201b-afeb-41ca-a03d-2281c28322aa\": {\r\n    \"name\": \"ATKey.Pro CTAP2.1\"\r\n  },\r\n  \"9f77e279-a6e2-4d58-b700-31e5943c6a98\": {\r\n    \"name\": \"Hyper FIDO Pro\"\r\n  },\r\n  \"73402251-f2a8-4f03-873e-3cb6db604b03\": {\r\n    \"name\": \"uTrust FIDO2 Security Key\"\r\n  },\r\n  \"c1f9a0bc-1dd2-404a-b27f-8e29047a43fd\": {\r\n    \"name\": \"YubiKey 5 FIPS Series with NFC\"\r\n  },\r\n  \"504d7149-4e4c-3841-4555-55445a677357\": {\r\n    \"name\": \"WiSECURE AuthTron USB FIDO2 Authenticator\"\r\n  },\r\n  \"cb69481e-8ff7-4039-93ec-0a2729a154a8\": {\r\n    \"name\": \"YubiKey  5 Series\"\r\n  },\r\n  \"ee882879-721c-4913-9775-3dfcce97072a\": {\r\n    \"name\": \"YubiKey 5 Series\"\r\n  },\r\n  \"8c97a730-3f7b-41a6-87d6-1e9b62bda6f0\": {\r\n    \"name\": \"FT-JCOS FIDO Fingerprint Card\"\r\n  },\r\n  \"a1f52be5-dfab-4364-b51c-2bd496b14a56\": {\r\n    \"name\": \"OCTATCO EzFinger2 FIDO2 AUTHENTICATOR\"\r\n  },\r\n  \"3e078ffd-4c54-4586-8baa-a77da113aec5\": {\r\n    \"name\": \"Hideez Key 3 FIDO2\"\r\n  },\r\n  \"d41f5a69-b817-4144-a13c-9ebd6d9254d6\": {\r\n    \"name\": \"ATKey.Card CTAP2.0\"\r\n  },\r\n  \"bc2fe499-0d8e-4ffe-96f3-94a82840cf8c\": {\r\n    \"name\": \"OCTATCO EzQuant FIDO2 AUTHENTICATOR\"\r\n  },\r\n  \"1c086528-58d5-f211-823c-356786e36140\": {\r\n    \"name\": \"Atos CardOS FIDO2\"\r\n  },\r\n  \"77010bd7-212a-4fc9-b236-d2ca5e9d4084\": {\r\n    \"name\": \"Feitian BioPass FIDO2 Authenticator\"\r\n  },\r\n  \"833b721a-ff5f-4d00-bb2e-bdda3ec01e29\": {\r\n    \"name\": \"Feitian ePass FIDO2 Authenticator\"\r\n  }\r\n}", "import authenticatorMetadata from './authenticatorMetadata' //assert {type: 'json'}\r\nimport * as utils from './utils'\r\n\r\n\r\nexport function parseAuthBuffer(authData :ArrayBuffer) {\r\n    console.debug(authData)\r\n    let flags = new DataView(authData.slice(32,33)).getUint8(0)\r\n    console.debug(flags)\r\n\r\n    // https://w3c.github.io/webauthn/#sctn-authenticator-data\r\n    let parsed :any = {\r\n        rpIdHash: utils.toBase64url(authData.slice(0,32)),\r\n            flags: {\r\n                 userPresent: !!(flags & 1),\r\n                 //reserved1: !!(flags & 2),\r\n                 userVerified: !!(flags &  4),\r\n                 backupEligibility: !!(flags & 8),\r\n                 backupState: !!(flags & 16),\r\n                 //reserved2: !!(flags & 32),\r\n                 attestedData: !!(flags & 64),\r\n                 extensionsIncluded: !!(flags & 128)\r\n            },\r\n            counter: new DataView(authData.slice(33,37)).getUint32(0, false),  // Big-Endian!\r\n    }\r\n\r\n    if(authData.byteLength > 37) {\r\n        // registration contains additional data\r\n\r\n        const aaguid = extractAaguid(authData)\r\n        // https://w3c.github.io/webauthn/#attested-credential-data\r\n        //let credentialLength = new DataView(authData.slice(53,55)).getUint16(0, false) // Big-Endian!\r\n        \r\n        parsed = {\r\n            ...parsed,\r\n            aaguid, // bytes 37->53\r\n            name: resolveAuthenticatorName(aaguid)\r\n            // credentialBytes, // bytes 53->55: credential length\r\n            // credentialId: utils.toBase64url(authData.slice(55, 55+credentialLength)),\r\n            //publicKey: until where? ...and it's encoded using a strange format, let's better avoid it\r\n            //extensions: starting where?\r\n        }\r\n    }\r\n\r\n    return parsed\r\n}\r\n\r\nexport function extractAaguid(authData :ArrayBuffer) :string {\r\n    return formatAaguid(authData.slice(37, 53)) // 16 bytes\r\n}\r\n\r\nfunction formatAaguid(buffer :ArrayBuffer) :string {\r\n    let aaguid = utils.bufferToHex(buffer)\r\n    aaguid = aaguid.substring(0,8) + '-' + aaguid.substring(8,12) + '-' + aaguid.substring(12,16) + '-' + aaguid.substring(16,20) + '-' + aaguid.substring(20,32)\r\n    return aaguid // example: \"d41f5a69-b817-4144-a13c-9ebd6d9254d6\"\r\n}\r\n\r\nexport function resolveAuthenticatorName(aaguid :string) :string {\r\n    const aaguidMetadata = updatedAuthenticatorMetadata ?? authenticatorMetadata //await getAaguidMetadata()\r\n    return aaguidMetadata[aaguid]?.name\r\n}\r\n\r\nlet updatedAuthenticatorMetadata :any = null\r\n\r\n// List of AAGUIDs are encoded as JWT here: https://mds.fidoalliance.org/\r\nexport async function updateDevicesMetadata() {\r\n    // this function is rather resource intensive and time consuming\r\n    // therefore, the result is cached in local storage\r\n    const jwt = await (await fetch(\"https://mds.fidoalliance.org\")).text()\r\n\r\n    // the response is a JWT including all AAGUIDs and their metadata\r\n    console.debug(jwt)\r\n\r\n    // let us ignore the JWT verification, since this is solely for descriptive purposes, not signed data\r\n    const payload = jwt.split('.')[1].replaceAll('-', '+').replaceAll('_', '/')\r\n    const json = JSON.parse(atob(payload))\r\n    console.debug(json)\r\n\r\n    let aaguidMetadata :any = {}\r\n    for(const e of json.entries) {\r\n        if(!e.aaguid || !e.metadataStatement)\r\n            continue\r\n\r\n        aaguidMetadata[e.aaguid] = {name: e.metadataStatement.description}\r\n    }\r\n\r\n    console.debug(aaguidMetadata)\r\n    updatedAuthenticatorMetadata = aaguidMetadata\r\n}\r\n"],
  "mappings": "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",
  "names": ["client_exports", "__export", "authenticate", "isAvailable", "isLocalAuthenticator", "register", "utils_exports", "__export", "bufferToHex", "concatenateBuffers", "isBase64url", "parseBase64url", "parseBuffer", "randomChallenge", "sha256", "toBase64url", "toBuffer", "txt", "c", "buffer", "b", "buffer1", "buffer2", "tmp", "isAvailable", "isLocalAuthenticator", "getAuthAttachment", "authType", "getAlgoName", "num", "register", "username", "challenge", "options", "isBase64url", "creationOptions", "parseBase64url", "sha256", "credential", "response", "registration", "toBase64url", "getTransports", "local", "roaming", "authenticate", "credentialIds", "transports", "authOptions", "id", "auth", "server_exports", "__export", "verifyAuthentication", "verifyRegistration", "verifySignature", "parsers_exports", "__export", "parseAttestation", "parseAuthentication", "parseAuthenticator", "parseClient", "parseRegistration", "authenticatorMetadata_default", "parseAuthBuffer", "authData", "flags", "parsed", "toBase64url", "aaguid", "extractAaguid", "resolveAuthenticatorName", "formatAaguid", "buffer", "bufferToHex", "updatedAuthenticatorMetadata", "authenticatorMetadata_default", "utf8Decoder", "parseClient", "data", "parseBase64url", "parseAuthenticator", "parseAuthBuffer", "parseAttestation", "parseRegistration", "registration", "parseAuthentication", "authentication", "isValid", "validator", "value", "res", "isNotValid", "verifyRegistration", "registrationRaw", "expected", "registration", "parseRegistration", "verifyAuthentication", "authenticationRaw", "credential", "verifySignature", "authentication", "parseAuthentication", "rpId", "expectedRpIdHash", "toBase64url", "sha256", "toBuffer", "getAlgoParams", "algorithm", "parseCryptoKey", "algoParams", "publicKey", "buffer", "parseBase64url", "authenticatorData", "clientData", "signature", "cryptoKey", "clientHash", "comboBuffer", "concatenateBuffers", "signatureBuffer", "convertASN1toRaw", "usignature", "rStart", "rEnd", "sStart", "r", "s"]
}
